namespace _04._Queue
{
    internal class Program
    {
        /******************************************************
         * 큐 (Queue)
         * 
         * 선입선출(FIFO), 후입후출(LILO) 방식의 자료구조
         * 입력된 순서대로 처리해야 하는 상황에 이용
         ******************************************************/

        // <큐 구현>
        // 1. 배열 사용
        // 선입선출(FIFO), 후입후출(LILO) 을 구현하기 위해 배열을 생성하고 순차적으로 데이터를 배치
        //     ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  앞 │1│2│3│4│5│ │ │ │  뒤
        //     └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // - 삽입 -
        // 비어있는 가장 뒷쪽에 데이터를 배치
        //  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  │1│2│3│4│5│ │ │ │   =>   │1│2│3│4│5│6│ │ │
        //  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // - 삭제 -
        // 가장 앞쪽 데이터를 출력하고 빈자리를 채우기 위해 나머지 데이터를 앞당기기 진행
        //  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  │1│2│3│4│5│6│ │ │   =>   │2│3│4│5│6│ │ │ │
        //  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // - 문제발생 -
        // 큐의 삭제 과정시 나머지 데이터를 앞당겨야하는 N번의 작업 발생
        //  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  │1│2│3│4│5│6│ │ │   =>   │ │2│3│4│5│6│ │ │   =>   │2│3│4│5│6│ │ │ │
        //  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

        // 2. 전단 & 후단
        // 삽입 & 삭제 시 데이터를 앞당기지 않고 head와 tail을 표시하여 삽입할 위치와 삭제할 위치를 지정
        //
        // - 삽입 -
        // tail 위치에 데이터를 추가하고 tail을 한칸 뒤로 이동
        //     h       t                h         t
        //     ↓       ↓                ↓         ↓      
        //  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  │ │2│3│4│5│ │ │ │   =>   │ │2│3│4│5│6│ │ │
        //  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // - 삭제 -
        // head 위치에 데이터를 추가하고 head을 한칸 뒤로 이동
        //     h         t                h       t
        //     ↓         ↓                ↓       ↓
        //  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  │ │2│3│4│5│6│ │ │   =>   │ │ │3│4│5│6│ │ │
        //  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // - 문제발생 -
        // 큐의 배열 마지막 위치까지 사용하는 경우 빈자리가 없어 저장 불가한 상황 발생
        //       h         t              h           t
        //       ↓         ↓              ↓           ↓
        //  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        //  │ │ │3│4│5│6│7│ │   =>   │ │ │3│4│5│6│7│8│
        //  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

        // 3. 순환배열
        // 배열의 끝까지 도달하여 빈자리가 없을 경우 처음으로 돌아가서 빈공간을 활용
        //
        // - 마지막위치 도달시 -
        // 다시 가장 앞 위치를 사용하여 빈공간을 재활용
        //          h     t          t       h           
        //          ↓     ↓          ↓       ↓           
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │ │ │ │ │5│6│7│ │   =>   │ │ │ │ │5│6│7│8│
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // - 문제발생 -
        // tail이 head을 침범하는 경우 모든 공간이 비어있는 상황과 가득차 있는 상황을 구분할 수 없음
        // 
        //         th                       th       
        //         ↓↓                       ↓↓       
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │ │ │ │ │ │ │ │ │        │5│6│7│8│1│2│3│4│
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //   비어있는 경우             가득찬 경우

        // 4. 포화상태확인
        // head와 tail이 일치하는 경우를 비어있는 경우로 판정
        // tail이 head 전위치에 있는 경우를 실제로는 한자리가 비어있지만 가득찬 경우로 판정
        //         th                      t h       
        //         ↓↓                      ↓ ↓       
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │ │ │ │ │ │ │ │ │        │5│6│7│ │1│2│3│4│
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
        //   비어있는 경우         가득찬 경우(로 판정)

        
        static void Main(string[] args)
        {
            Queue<int> queue = new Queue<int>();

            for (int i = 0; i < 5; i++)
            {
                queue.Enqueue(i);                       // 입력순서 : 0, 1, 2, 3, 4
            }

            Console.WriteLine(queue.Peek());            // 다음순서 : 0

            for (int i = 0; i < 3; i++)
            {
                Console.WriteLine(queue.Dequeue());     // 출력순서 : 0, 1, 2
            }

            Console.WriteLine(queue.Peek());            // 다음순서 : 3

            for (int i = 5; i < 10; i++)
            {
                queue.Enqueue(i);                       // 입력순서 : 5, 6, 7, 8, 9
            }

            Console.WriteLine(queue.Peek());            // 다음순서 : 3

            while (queue.Count > 0)
            {
                Console.WriteLine(queue.Dequeue());     // 출력순서 : 3, 4, 5, 6, 7, 8, 9
            }
        }
    }
}
